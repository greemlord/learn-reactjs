<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/training-project/app-state" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="Url" value=""/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page app-state-page">
    <h1>5.8 Состояние приложения</h1>

    <br/>

    <p class="introduction">
        В этом разделе речь пойдёт о таком таком крайне важном в настоящее время
        элементе приложения как состояние.  React даёт нам возможность работать с
        состоянием компонента. Дочерний компонент может узнать об изменении состояния
        родителя через props. Но как быть, когда компоненты не имеют общего предка?
        Приложение постоянно получает и посылает данные на сервер, как об этом может
        знать множество компонентов? Можно ли хранить данные приложения в каком-нибудь
        централизованном хранилище, чтобы к нему имели доступ желаемые компоненты? Эти и
        масса похожих вопросов небезосновательны. Они требуют серьёзного рассмотрения,
        так как неизбежно возникают по мере роста приложения.
    </p>

    <br/>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.8.1 Мотивация</h2>
    <br/>

    <p>
        В настоящее время требования к одностраничным JavaScript-приложениям
        становятся все более сложными. В связи с этим наш код как никогда нуждается
        в наличии состояния, и управлении им. Состояние может включать ответы сервера,
        кэшированные данные, а также данные, созданные локально, но пока не сохранённые
        на сервере. Структура состояния тоже становится всё сложнее, поскольку нам
        необходимо управлять активными маршрутами, выбранными вкладками, спинерами,
        контролами пагинации и так далее.
    </p>

    <p>
        <b>Управлять постоянно изменяющимся состоянием сложно.</b> Если модель может обновлять
        другую модель, то представление может обновить модель, которая обновит другую модель,
        и это, в свою очередь, может привести к обновлению другого представления. В какой-то
        момент вы уже не понимаете, что происходит в вашем приложении, поскольку потеряли
        контроль над тем, когда, почему и как изменяется ваше состояние. Когда система не
        прозрачна и не детерминирована, очень трудно воспроизвести баги или добавить новые функции.
    </p>

    <p>
        Ко всему прочему, появились <b>новые требования, которые стали традиционными при разработке
        фронтэнда</b>. От нас, как от разработчиков, ожидают уверенной работы с оптимистичными
        обновлениями, отрисовкой на стороне сервера, загрузкой данных перед выполнением переходов
        по маршруту и так далее. Пытаясь справиться со сложностью, с которой нам никогда не
        приходилось сталкиваться прежде, мы неизбежно задаем себе вопрос: пора ли сдаваться?
        Ответ - нет.
    </p>

    <c:url var="reduxUrl" value="https://redux.js.org/"/>

    <p>
        С этой сложностью трудно справиться, поскольку мы смешиваем две концепции,
        которые человеческому разуму трудно совместить: <b>мутация и асинхронность</b>. Они как Ментос и Кола.
        Оба могут быть хороши по отдельности, но вместе создают настоящий хаос. Такие библиотеки,
        как React, пытаются решить эту проблему на уровне представления путем устранения как
        асинхронности, так и прямой манипуляции с DOM. Однако управление состоянием ваших данных
        остается за вами. Это как раз тот момент, когда в большую игру
        вступает <b><a href="${reduxUrl}">Redux</a></b>.
    </p>

    <p>
        Следуя в одном направлении за Flux, CQRS и Event Sourcing, Redux пытается
        сделать изменения состояния предсказуемыми, налагая определенные ограничения
        на то, <b>как</b> и <b>когда</b> могут происходить обновления. Эти ограничения отражены в
        <b>трех принципах</b> Redux.
    </p>

    <p>
        Возвращаясь к контексту нашего приложения, следует отметить, что на
        данный момент мы используем только локальное состояние компонента, чтобы хранить в
        нём какие-либо данные. Например компонент <code>&lt;Appointments&gt;</code> хранит переменную
        состояния <code>date</code>, для того чтобы поместить в неё данные, пришедшие с сервера.
        Для подгрузки же данных мы используем метод <code>find()</code> сервиса <code>AppointmentService</code>:
    </p>

    <ce:code-example-1/>

    <p>
        Этот код занимает 13 строк. А теперь представьте, что в одном компоненте <code>&lt;Assessments&gt;</code>
        нам нужно определить 5-10 подобных методов, осуществляющих подгрузку разнообразных данных
        с сервера. При этом состоянием компонента мы управляем вручную, используя в определённых
        местах вызов <code>this.setState()</code>.
    </p>

    <p>
        По мере того, как число сервисов и методов в них начнёт увеличиваться, код
        компонентов также начнёт расти. В свою очередь, число компонентов, которые
        вызывают методы сервисов (наподобие нашего <code>&lt;Assessments&gt;</code>) может составлять
        несколько десятков (а то и больше). Также многие компоненты могут
        использовать одни и те же методы сервисов. То есть возможно дублирование кода.
    </p>

    <p>Итак, с ростом нашего React-приложения мы получим следующие проблемы:</p>

    <ul>
        <li>
            <p>
                Рост объема типового кода для подгрузки серверных данных
            </p>
        </li>
        <li>
            <p>
                Дублирование кода
            </p>
        </li>
        <li>
            <p>
                Станет сложнее находить и исправлять ошибки
            </p>
        </li>
        <li>
            <p>
                Станет сложнее управлять состоянием компонента, ввиду увеличения
                числа вызовов <code>this.setState()</code>.
            </p>
        </li>
    </ul>

    <p>
        Вот почему нам так нужна библиотека Redux. Мы увидим как с её помощью
        преобразится код нашего приложения, а также насколько эффективно будут решены
        вышеперечисленные проблемы.
    </p>

    <c:url var="fluxUrl" value="https://facebook.github.io/flux/"/>
    <c:url var="mobxUrl" value="https://github.com/mobxjs/mobx"/>

    <p>
        Кстати, Redux - это не единственная библиотека, которая осуществляет работу с
        состоянием. Также весьма популярными являются библиотеки
        <b><a href="${fluxUrl}">Flux</a></b> и <b><a href="${mobxUrl}">mobx</a></b>, применяющие
        собственные концепции и API. <b>Вам непременно стоит обратить на них внимание</b>.
        Возможно какой-то из этих библиотек вы отдадите большее предпочтение.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.8.2 Библиотека Redux</h2>
    <br/>

    <br/>
    <h3>5.8.2.1 Базовые концепции</h3>
    <br/>

    <p>
        Представьте, что состояние вашего приложения это простой JS-объект. Допустим, у нас
        есть приложение <b>todo</b>, тогда его состояние может выглядеть следующим образом:
    </p>

    <ce:code-example-2/>

    <p>
        Этот объект похож на «модель», однако здесь нет сеттеров. Это сделано для того,
        чтобы различные части кода не могли произвольно изменять состояние, что приводило
        бы к трудно воспроизводимым ошибкам.
    </p>

    <p>
        Чтобы что-то изменить в состоянии, нужно отправить действие. Действие - это простой
        объект JavaScript, который описывает, что именно произошло. Вот несколько примеров действий:
    </p>

    <ce:code-example-3/>

    <p>
        Благодаря тому, что <b>каждое изменение состояния происходит в ответ на какое-либо
        действие</b>, мы имеем четкое представление о том, что происходит в приложении. Если
        что-то изменилось, мы знаем, почему это изменилось.
    </p>

    <p>
        Наконец, чтобы связать состояние и действия вместе, мы пишем функцию, называемую
        <b>редюсером/редуктором</b>. Ничего волшебного в нём нет - это просто функция, которая
        принимает текущее состояние и действие в качестве аргументов и возвращает следующее
        состояние приложения. Было бы сложно написать одну такую функцию для большого приложения,
        поэтому мы пишем <b>более мелкие функции, управляющие соответствующими частями состояния</b>:
    </p>

    <ce:code-example-4/>

    <p>
        Напишем еще один редюсер, который управляет полным состоянием нашего приложения, вызывая эти
        два редюсера для соответствующих ключей состояния:
    </p>

    <p>
        <b>Это и есть вся идея Redux!</b> Обратите внимание, что мы не использовали Redux API.
        Redux поставляется с несколькими утилитами для упрощения этого шаблона, но основная
        идея заключается в том, что вы описываете, как ваше состояние обновляется с течением
        времени в ответ на объекты действий, и 90% кода, который вы пишете, - это простой
        JavaScript, без использования самого Redux, его API, или любой другой магии.
    </p>

    <br/>
    <h3>5.8.2.2 Три базовых принципа</h3>
    <br/>

    <p>Redux основан на трех базовых принципах:</p>

    <br/>
    <h4>&#1758; <u>Единственный источник истины.</u></h4>
    <br/>

    <p>
        <b>
            Состояние всего вашего приложения хранится в древовидном объекте в едином хранилище.
        </b>
    </p>

    <p>
        Это облегчает создание универсальных приложений, поскольку состояние вашего сервера
        может быть сериализовано и перенесено в клиент без дополнительных усилий по написанию
        кода. Единое дерево состояния облегчает отладку и проверку приложения. Оно также позволяет
        сохранять состояние вашего приложения в процессе разработки, что сильно ускоряет её цикл.
        Некоторые традиционно сложные в реализации функции, такие как Отменить/Повторить, могут
        внезапно стать тривиальными, если всё ваше состояние хранится в одном дереве.
    </p>

    <br/>
    <h4>&#1758; <u>Состояние предназначено только для чтения.</u></h4>
    <br/>

    <p>
        <b>
            Единственный способ изменить состояние - это совершить действие, отправив соответствующий
            объект с необходимым описанием.
        </b>
    </p>

    <p>
        Это гарантирует, что ни представления, ни сетевые коллбэки никогда не будут изменять
        состояние напрямую. Вместо этого они выражают лишь намерение преобразовать состояние.
        Поскольку все изменения централизованы и происходят одно за другим в строгом порядке,
        не существует каких-либо особых условий, на которые стоит обратить внимание. Дескрипторы
        действий являются просто обычными объектами, которые можно логировать, сериализовать,
        хранить, а затем воспроизводить для целей отладки и тестирования.
    </p>

    <br/>
    <h4>&#1758; <u>Изменения производятся чистыми функциями.</u></h4>
    <br/>

    <p>
        Чтобы указать, как трансформировать дерево состояния посредством действий, используются
        чистые функции-редюсеры.
    </p>

    <p>
        Редюсеры - это обычные чистые функции, которые принимают предыдущее состояние и
        действие и возвращают следующее состояние. Не забывайте возвращать новые объекты
        состояния, вместо того, чтобы изменять предыдущее состояние. Вы можете начать с
        одного редюсера и по мере роста вашего приложения разделить его на более мелкие,
        которые управляют определенными частями дерева состояния. Поскольку редюсеры -
        это просто функции, вы можете контролировать порядок их вызова, передавать
        дополнительные данные или даже создавать повторно используемые редюсеры для
        общих задач, таких как пагинация.
    </p>

    <p>Вот пример создания редюсера приложения, используя Redux API:</p>

    <ce:code-example-6/>

    <p>Это всё! Теперь вы знаете, что такое Redux.</p>

    <br/>
    <h3>5.8.2.3 Redux API</h3>
    <br/>

    <p>
        Мы уже познакомились с назначением и базовыми концепциями библиотеки Redux.
        Далее вам следует разобраться с её API. Я не буду дублировать уже имеющуюся
        информацию, а лишь сориентирую вас на готовые руководства.
    </p>

    <c:url var="reduxDocsUrl" value="https://redux.js.org/introduction/getting-started"/>
    <c:url var="reduxInRussianUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/introduction/"/>

    <p>
        Оригинал документации <b><a href="${reduxDocsUrl}">находится здесь</a></b>.
        Также существует неплохой <b><a href="${reduxInRussianUrl}">русскоязычный перевод</a></b>.
        Для базового понимания Redux API вам обязательно нужно изучить следующие
        разделы из базового руководства:
    </p>

    <c:url var="actionsUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/Actions.html"/>
    <c:url var="reducersUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/Reducers.html"/>
    <c:url var="storeUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/Store.html"/>
    <c:url var="dataFlowUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/DataFlow.html"/>
    <c:url var="usageWithReactUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/UsageWithReact.html"/>
    <c:url var="exampleTodoListUrl" value="https://rajdee.gitbooks.io/redux-in-russian/content/docs/basics/ExampleTodoList.html"/>

    <ul>
        <li>
            <p>
                <b><a href="${actionsUrl}">Действия (Actions)</a></b>
            </p>
        </li>
        <li>
            <p>
                <b><a href="${reducersUrl}">Редюсеры (Reducers)</a></b>
            </p>
        </li>
        <li>
            <p>
                <b><a href="${storeUrl}">Хранилище (Store)</a></b>
            </p>
        </li>
        <li>
            <p>
                <b><a href="${dataFlowUrl}">Поток данных (Data Flow)</a></b>
            </p>
        </li>
        <li>
            <p>
                <b><a href="${usageWithReactUrl}">Использвание с React</a></b>
            </p>
        </li>
        <li>
            <p>
                <b><a href="${exampleTodoListUrl}">Пример: Todo List</a></b>
            </p>
        </li>
    </ul>

    <p>
        Их вполне хватит для понимания того, что мы будем делать дальше. Ну а
        если хотите стать настоящим асом - изучайте <b><a href="${reduxDocsUrl}">все разделы оригинала</a></b>.
        Это будет потрясающе!
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.8.3 Архитектура</h2>
    <br/>

    <p>
        Самое главное, что необходимо сделать вначале перед подключением библиотеки Redux -
        это задать структуру объекта состояния приложения. Исходя из своего опыта, для нашего
        приложения я предлагаю задать следующую структуру:
    </p>

    <ce:code-example-7/>

    <p>
        Предложенная структура интуитивно понятна и позволяет решать практически
        любые задачи по хранению данных в состоянии приложения. На самом деле выше
        показан лишь маленький пример. Такая структура объекта состояния позволяет
        хранить данные не только списков, но и форм, деталей, истории и пр. :
    </p>

    <ce:code-example-8/>

    <p>
        Как видно объект состояния может быть довольно большим. Здесь представлена
        структура лишь для всего, что касается приёмов. Но ведь приложение может содержать
        информацию по пользователям, аутентификации и так далее. В реальных проектах размер
        данного объекта может доходить до 20 и более полей самого верхнего (корневого) уровня!
        У нас же пока только одно такое поле: <code>appointments</code>.
    </p>

    <p>
        Если вы уже хорошо ознакомились с Redux API, то используя предложенную структуру
        объекта состояния мы можем осуществлять доступ к хранящимся в нём данным из классов-контейнеров
        следующим образом:
    </p>

    <ce:code-example-9/>

    <p>
        Как видно, при доступе к необходимым данным у нас перед глазами всегда
        понятная и подробная структура объекта состояния. Благодаря тому, что она
        максимально шаблонная, её легко запомнить, и, что очень важно, в ней довольно
        просто сориентироваться, особенно если код пишет несколько разработчиков. Кроме
        того, этот код доступа к данным можно сократить, далее будет показано как
        это можно сделать.
    </p>

    <p>
        Что ж, самую важную часть мы выполнили. Теперь перейдём к внедрению
        библиотеки Redux в наш проект.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.8.4 Интеграция с библиотекой Redux</h2>
    <br/>

    <br/>
    <h3>5.8.4.1 Библиотека Immutable.js</h3>
    <br/>

    <c:url var="immutableUrl" value="https://habr.com/ru/company/piter/blog/317248/"/>
    <c:url var="immutableDocsUrl" value="https://immutable-js.github.io/immutable-js/docs/#/"/>
    <c:url var="immutableHabrUrl" value="https://habr.com/ru/company/devexpress/blog/302118/"/>

    <p>
        Если вы никогда раньше не слышали об иммутабельности, настала пора с ней
        познакомиться. Чтобы понять, для чего же нужна иммутабельность вы можете
        прочитать <b><a href="${immutableUrl}">эту неплохую статью</a></b> на хабре. Для более подробного знакомства с
        библиотекой Immutable я рекомендую обратиться к <b><a href="${immutableDocsUrl}">официальной документации</a></b> и
        почитать <b><a href="${immutableHabrUrl}">эту замечательную статью</a></b>.
    </p>

    <c:url var="recordUrl" value="https://immutable-js.github.io/immutable-js/docs/#/Record"/>

    <p>
        Мы будем использовать иммутабельность в наших состояниях и редюсерах.
        В самой библиотеке Immutable есть такой замечательный класс под
        названием <b><a href="${recordUrl}">Record</a></b>. Нам он очень удобен
        потому, что по своему поведению довольно похож на обычный объект JS.
        Давайте рассмотрим его API:
    </p>

    <ce:code-example-10/>

    <p>
        Вызов функции <code>Record()</code> создает новую фабрику. Фабрика тоже является функцией,
        и её вызов создаёт экземпляры <code>Record</code>. Всё очень просто.
    </p>

    <p>
        Объект <code>Record</code> всегда имеет значение для ключей, которые он определяет. Удаление ключа из
        объекта просто сбрасывает его к значению по умолчанию для этого ключа.
    </p>

    <ce:code-example-11/>

    <p>
        Значения, предоставленные конструктору при создании объекта, но не найденные
        в определённом Record-типе, будут игнорироваться.
    </p>

    <ce:code-example-12/>

    <p>
        Фабрике <code>ABRecord</code> предоставили ключ <code>"x"</code>, хотя для типа создаваемого объекта
        мы определили только ключи <code>"a"</code> и <code>"b"</code>. Значение для <code>"x"</code> будет проигнорировано
        для этого объекта.
    </p>

    <p>
        Чтобы получить доступ к значению ключа объекта <code>Record</code>
        используется метод <code>get()</code>:
    </p>

    <ce:code-example-13/>

    <p>
        Если запрошенный ключ не определен Record-типом, будет  возвращен <code>notSetValue</code>, если
        он указан. Обратите внимание, что этот сценарий приведет к ошибке при использовании
        Flow или TypeScript.
    </p>

    <p>
        Чтобы узнать, содержит ли объект определённый ключ, используется
        метод <code>has()</code>:
    </p>

    <ce:code-example-14/>

    <p>
        Чтобы установить значение ключа, используется метод <code>set()</code>:
    </p>

    <ce:code-example-15/>

    <p>
        Выше мы рассмотрели работу с простым объектом, не содержащим вложенности. Однако
        библиотека отлично справляется и с многоуровневыми объектами:
    </p>

    <ce:code-example-16/>

    <p>Вы можете вдоволь поиграться с библиотекой прямо в консоли на её сайте:</p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/immutable.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Что ж, знакомство с иммутабельностью и классом Record подошло к концу.
        Следующим шагом будет создание всех необходимых компонентов Redux.
    </p>

    <br/>
    <h3>5.8.4.2 Действия, редюсер и состояние списка</h3>
    <br/>

    <p>
        Ранее мы определили структуру объекта состояния приложения. Теперь
        нам необходимо создать соответствующие действия, редюсеры и состояние.
        Для них лучше всего определить отдельную папку, назовём её <code>/redux</code>.
        Название папки может быть любым, но поскольку мы будем хранить генераторы
        действий, редюсер и состояние в одном месте, то название должно быть
        совокупным. Поэтому имя <code>/redux</code>, на мой взгляд самое подходящее. Структура
        этой папки будет соответствовать структуре объекта состояния, это
        обеспечит понятность и простоту ориентирования.
    </p>

    <p>
        Давайте создадим файлы генераторов действий, редюсера и состояния для
        нашего списка приёмов:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/redux-structure.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Здесь файлы названы полным именем: <code>что-тоActions.js</code>. Мы могли бы
        назвать просто <code>actions.js</code>. Но тогда это усложнило бы поиск файла в среде
        разработки. Поэтому полное имя лучше оставить.
    </p>

    <p>
        Что ж, самое время создать необходимые генераторы действий
        в файле <code>appointmentListActions.js</code>:
    </p>

    <ce:code-example-17/>

    <p>
        Как вы уже читали ранее, действие в Redux представлено простым JS объектом.
        В этом файле мы определили функции, которые будут создавать и возвращать такие
        объекты при вызове. Они называются генераторами действий.
    </p>

    <c:url var="asyncActionsUrl" value="https://redux.js.org/advanced/async-actions#async-action-creators"/>

    <p>
        Особого внимания заслуживает генератор <code>load()</code>. Как вы уже читали в
        <b><a href="${asyncActionsUrl}">документации Redux</a></b>, для подгрузки данных с сервера нужен мидлвар <code>thunkMiddleware</code>.
        Далее мы подключим его, а пока представим, что он уже подключён. Метод интересен
        тем, что он является асинхронным генератором действия. Как только он был вызван,
        сначала генерируется действие <code>dispatch({ type: 'LOAD_APPOINTMENT_LIST_REQUEST' })</code>
        с помощью функции <code>dispatch()</code>. Затем мы вызываем наш сервис и ожидаем ответа от
        сервера. В случае успешной обработки запроса мы генерируем действие
        типа <code>'LOAD_APPOINTMENT_LIST_SUCCESS'</code>, а если произошли какие-то ошибки -
        действие типа <code>'LOAD_APPOINTMENT_LIST_FAILURE'</code>.
    </p>

    <p>
        Если вы обратили внимание, я использовал строковые литералы. Они удобны,
        пока проект мал. В нашем случае лучше перейти на строковые константы.
        Для этой цели создадим файл <code>Constants.js</code> в папке <code>/lib</code> и определим в нём
        все необходимые типы действий в виде констант:
    </p>

    <ce:code-example-19/>

    <c:url var="keyMirrorUrl" value="https://github.com/wmira/key-mirror"/>

    <p>
        Здесь используется библиотека <b><a href="${keyMirrorUrl}">key-mirror</a></b>. Она очень удобна, так как
        позволяет сократить код. Сравните:
    </p>

    <ce:code-example-20/>

    <p>
        Итоговый код файла генераторов действий <code>appointmentListActions.js</code> будет таким:
    </p>

    <ce:code-example-21/>

    <p>Теперь зададим состояние списка в файле <code>AppointmentListInitialState.js</code>:</p>

    <ce:code-example-22/>

    <p>
        Эта структура нам хорошо знакома, мы лишь применили библиотеку <b>Immutable.js</b>.
    </p>

    <p>
        Остался последний элемент - редюсер. Определим его в файле <code>appointmentListReducer.js</code>:
    </p>

    <ce:code-example-23/>

    <p>
        Код довольно прост: мы возвращаем обновлённое состояние списка с изменившимися значениями
        в ответ на соответствующие действия.
    </p>

    <p>Обратите внимание на код:</p>

    <ce:code-example-24/>

    <c:url var="handlingActionsUrl" value="https://redux.js.org/basics/reducers#handling-actions"/>

    <p>
        Он является необходимым, так как Redux вызовет наш редюсер в первый
        раз со значением <code>state === undefined</code>. Это как раз то место, где мы
        возвращаем начальное состояние приложения. Подробно об этом
        <b><a href="${handlingActionsUrl}">написано здесь</a></b>.
    </p>

    <p>
        Что ж, со списком приёмов мы закончили. Но прежде чем перейти к корневому
        редюсеру, нам нужно создать еще промежуточные редюсер и состояние. Нужно
        это для того, чтобы соответствовать определённой нами структуре объекта
        состояния. Это просто ещё один промежуточный уровень:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/redux-structure-2.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>Исходный код <code>AppointmentInitialState.js</code>:</p>

    <ce:code-example-25/>

    <p>Исходный код <code>appointmentReducer.js</code>:</p>

    <ce:code-example-26/>

    <p>
        Код промежуточного уровня состояния очень простой. А вот редюсер
        уже поинтереснее. В нём мы применяем редюсер списка к соответствующей
        части состояния <code>state.list</code>. Если состояние списка изменилось, изменяем
        соответствующую часть текущего состояния: <code>nextState.setIn(['list'], list)</code>.
    </p>

    <p>
        Вам может показаться излишне сложным писать промежуточные уровни, но
        на самом деле они выполняют очень важную функцию: поддержание полного
        соответствия между структурой объекта состояния приложения и структурой
        директории <code>/redux</code> - это очень большое преимущество с точки зрения
        понимания о ориентирования в коде. К тому же они очень быстро
        пишутся благодаря копипасту :)
    </p>

    <p>
        Вы можете отказаться от предложенной структуры объекта состояния и
        папки <code>/redux</code>, разработав что-то своё. <b>Но сделать это лучше в самом
        начале</b>, так как изменить уже используемую структуру крайне сложно и
        чревато крэшами приложения.
    </p>

    <p>
        Итак, мы подобрались к корневому редюсеру. Назовём его <code>rootReducer</code> и
        поместим в файл <code>rootReducer.js</code>:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/root-reducer.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>Вот его исходный код:</p>

    <ce:code-example-27/>

    <p>
        Папка <code>/redux</code> полностью готова. Следующим шагом будет
        подключение библиотеки к проекту.
    </p>

    <br/>
    <h3>5.8.4.3 Подключение Redux к проекту</h3>
    <br/>

    <p>
        Первое, с чего мы начнём - добавим все необходимые
        зависимости в файл <code>package.json</code>:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/dependencies.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>Подробнее о подключаемых модулях вы можете почитать в документации.</p>

    <p>Далее нам необходимо модифицировать файл <code>index.js</code>:</p>

    <ce:code-example-28/>

    <p>Проанализируем изменения:</p>

    <ul>
        <li>
            <p>
                Метод <code>getInitialState</code> задаёт начальное состояние приложения.
            </p>
        </li>
        <li>
            <p>
                Вызов <code>createStore</code> создаёт хранилище состояния приложения. К тому же
                здесь мы применяем необходимые мидлвары: <code>thunkMiddleware</code>, <code>routerMiddleware</code>
                и <code>applyMiddleware</code>.
            </p>
        </li>
        <li>
            <p>
                Компонент <code>&lt;Provider&gt;</code> принимает хранилище состояния
                в качастве свойства.
            </p>
        </li>
        <li>
            <p>
                Компонент <code>&lt;ConnectedRouter&gt;</code> обеспечивает совместную работу
                библиотек Router и Redux.
            </p>
        </li>
    </ul>

    <p>Далее на очереди <code>App.js</code>:</p>

    <ce:code-example-29/>

    <p>
        На этом подключение Redux к нашему приложению завершено. Здесь
        вы можете увидеть, что компоненты <code>&lt;Home&gt;</code> и <code>&lt;Appointments&gt;</code> находятся
        уже в папке <code>/containers</code>. Сейчас мы разберёмся почему это так.
    </p>

    <br/>
    <h3>5.8.4.4 Преобразование компонентов в контейнеры</h3>
    <br/>

    <p>
        Мы подключили Redux к приложению. У нас есть состояние, генераторы
        действий и редюсеры. Нам осталось объявить компоненты, которые будут
        иметь доступ к данным состояния и знать о любом его изменении. Такие
        компоненты в терминах Redux принято называть контейнерами, поэтому мы
        и определяем их в отдельную папку <code>/containers</code>, чтобы не путать с обычными
        компонентами, являющимися библиотечными.
    </p>

    <p>
        В нашем приложении кандидатами в контейнеры являются компоненты
        <code>&lt;Home&gt;</code>, <code>&lt;Appointments&gt;</code> и
        <code>&lt;Header&gt;</code>. Давайте переместим их в папку <code>/containers</code>:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/app-redux-containers.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Исходный код компонентов также необходимо модифицировать. Начнём
        с компонента <code>&lt;Header&gt;</code>:
    </p>

    <ce:code-example-30/>

    <p>
        Здесь немного изменений, но в этом контейнере есть нереализованный
        функционал: отображение текущего пользователя и кнопка "Выйти". Поэтому
        на данный момент контейнер не использует состояние и действия, а
        метод <code>connect(null, null)</code> принимает два аргумента <code>null</code>. Реализация
        функционала <b>регистрации</b> и <b>логина</b> будет вашим домашним заданием.
    </p>

    <p>Теперь следует преобразовать компонент <code>&lt;Home&gt;</code>:</p>

    <ce:code-example-31/>

    <p>
        Изменения такие же, как и в файле выше. Но напомню, наш пример очень простой.
        По мере роста функционала, почти каждый контейнер использует состояние и действия.
    </p>

    <p>
        А теперь перейдём к самому интересному. Преобразуем
        компонент <code>&lt;Appointments&gt;</code>:
    </p>

    <ce:code-example-32/>

    <p>Проанализируем код:</p>

    <ul>
        <li>
            <p>
                Маппер <code>mapStateToProps</code> осуществляет отображение необходимой части состояния
                в свойства контейнера. Маппер будет вызван каждый раз, когда состояние приложения
                изменилось. Каждый раз, когда состояние приложения изменяется, будет
                вызван метод <code>render()</code> контейнера. Нам необязательно передавать в контейнер
                всё состояние приложения. Обычно нам нужна лишь какая-то определённая
                его часть, то есть только те данные, которые контейнер использует. Для этого
                и нужен метод <code>mapStateToProps</code>.
            </p>
        </li>
        <li>
            <p>
                Маппер <code>mapDispatchToProps</code> осуществляет связывание контейнера с генераторами
                действий. Это даёт возможность делать вызов генератора действия в контейнере
                с помощью выражения <code>this.props.actions.load()</code>. После такого вызова будет создано
                действие, которое будет передано в редюсеры. Нужный редюсер опознает действие и
                вернет обновлённое состояние приложения. С этого момента состояние приложения
                изменилось, что повлечёт сначала вызов метода <code>mapStateToProps</code>, а затем
                метода <code>render()</code> контейнера.
            </p>
        </li>
        <li>
            <p>
                Состояние приложения доступно через <code>this.props</code>.
            </p>
        </li>
    </ul>

    <p>
        Ранее мы  вручную указывали начало и конец процесса подгрузки данных с сервера,
        вызывая <code>this.setState({ isLoading: true })</code> и <code>this.setState({ isLoading: false })</code>.
        В данном варианте кода мы заменили локальное состояние компонента <code>this.state</code> на
        состояние Redux. Теперь состояние подгрузки данных определяется с помощью нового
        флага <code>isFetching</code>, который изменяется с помощью действий. Это даёт возможность
        не засорять код контейнера вызовами <code>this.setState({ isLoading: ... })</code>,
        тем самым упрощая его!
    </p>

    <p>
        Вместо вызова метода <code>load()</code> сервиса <code>AppointmentService</code> напрямую из контейнера,
        мы теперь используем <code>this.props.actions.load()</code>. А если нам нужны какие-либо
        действия сразу после успешной загрузки данных, мы можем использовать метод <code>then()</code>:
    </p>

    <ce:code-example-33/>

    <p>
        Что ж, на этом всё! Теперь все необходимые преобразования компонентов
        выполнены. А чтобы окончательно разобраться во всех описанных выше деталях, вам
        следует поэкспериментировать с полноценным кодом примера:
    </p>

    <br/>

    <iframe
            height="400px"
            width="100%"
            src="https://repl.it/@stsiushkevich/custom-app-v37?lite=true"
            scrolling="no"
            frameborder="no"
            allowtransparency="true"
            allowfullscreen="true"
            sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>

    <br/>
    <br/>

    <p>
        Наверняка у вас мог возникнуть вопрос: <b>когда компонент следует преобразовать
        в контейнер?</b> Здесь я бы выделил <b>два доминирующих признака</b>, явно указывающих на то,
        что компонент следует преобразовать в контейнер:
    </p>

    <ol>
        <li>
            <p>
               <b>Компонент осуществляет загрузку(download) данных с сервера и/или
                подгрузку(upload) данных на сервер.</b> Очевидно, что для этого ему
                понадобятся действия. В случае нашего приложения ярким примером
                является компонент-контейнер <code>&lt;Appointments&gt;</code>, а
                в общем случае это обычно:
            </p>
            <ul>
                <li>
                    <p>
                        Компоненты, содержащие списки(таблицы) данных
                    </p>
                </li>
                <li>
                    <p>
                        Формы
                    </p>
                </li>
                <li>
                    <p>
                        Компоненты (страницы или модальные окна), отображающие детали
                        какой-либо сущности, например детали пациента.
                    </p>
                </li>
            </ul>
        </li>
        <li>
            <p>
                <b>Компонент должен реагировать на изменения состояния приложения.</b>
                Часто возникают ситуации, когда компонент должен обновляться, или
                выполнять какие-либо действия, если состояние приложения изменилось
                (обычно из-за действий другого компонента-контейнера). Примером может
                являться компонент, отображающий текущий статус пользователя.
            </p>
        </li>
    </ol>

    <p>
        Итак, я надеюсь, вы получили достаточно практической информации по
        использованию замечательной библиотеки Redux. Она способна серьёзно улучшить
        структуру вашего проекта, а также ощутимо упростить код компонентов, что естественно
        снижает вероятность ошибок. Кроме того, библиотека даёт массу полезных возможностей
        компонентам-контейнерам, таких как доступ к объекту истории и текущей локации(роутинг)
        через props, отслеживание состояния приложения, согласованное выполнение действий.
        Внедряя Redux в проект вы избегаете решения массы типовых проблем управления
        состоянием - это уже сделали за вас!
    </p>

    <c:url var="reduxNonReactUrl" value="https://codepen.io/leonli/pen/YqaPNZ"/>

    <p>
        Есть ещё одна хорошая новость: Redux можно внедрять и в нативное JS приложение,
        так как Redux-у не обязательно нужен именно React. Подключение не составляет никаких
        сложностей. Здесь можно посмотреть <b><a href="${reduxNonReactUrl}">небольшой пример</a></b>.
    </p>

    <p>
        На этом мы заканчиваем знакомство с состоянием приложения. Остаётся лишь пожелать
        вам успехов в приобретении практического опыта. <b>Не поленитесь и изучите Redux
        как можно глубже!</b> Поверьте, потраченное время с лихвой окупится понятным,
        масштабируемым кодом, лишенным досадных архитектурных ошибок.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.8.5 Пути рефакторинга</h2>
    <br/>

    <br/>
    <h3>5.8.5.1 Справочные данные</h3>
    <br/>

    <p>
        В нашем приложении на текущий момент с сервера загружается только список приёмов. 
        Как правило на подобной странице с сервера загружается гораздо больше данных. 
        Вспомним, что приём может иметь несколько статусов, например: "Завершён", "Активен", 
        "Пропущен" и пр. Было бы удобно фильтровать приёмы по статусу, например показывать 
        только завершённые приёмы. Давайте осуществим загрузку этих статусов с сервера и 
        посмотрим как изменится код нашего приложения.
    </p>
    
    <p>
        Итак, в файле <code>MockData.js</code> добавим новые фейковые данные для статусов:
    </p>

    <ce:code-example-34/>

    <p>
        Часто в приложениях есть такое подмножество данных, которые обычно запрашиваются
        все сразу. То есть их всегда не особо много, к ним не применяется пагинация и фильтрация.
        Типичными примерами являются: список географических областей или районов, список статусов,
        список каких-либо типов или групп и т.д. Такие данные можно охарактеризовать как <b>справочные</b>.
    </p>

    <p>
        Обратите внимание как справочные данные контрастируют с нашим списком приёмов. Размер списка
        приёмов растёт изо дня в день, поэтому без пагинации, фильтрации и сортировки работать с ним
        попросту невозможно. А вот со списком статусов, являющимся <b>справочными данными</b>, ничего подобного
        не происходит. Он обычно неизменен, данных немного - мы даже без труда можем видеть их все
        (хотя это необязательно). Сортировать, фильтровать или загружать по частям этот список нам не нужно.
    </p>

    <p>
        Коль мы выделили подмножество справочных данных, логично будет организовать их загрузку 
        неким специализированным сервисом, что избавит от кодовой нагрузки все остальные сервисы. 
        Слово "справочник" на английский часто переводится как "directory". Это довольно знакомое и 
        короткое слово, так что давайте возьмём его на вооружение и создадим специализированный сервис, 
        который будет загружать с сервера только справочные данные.
    </p>

    <p>
        Назовём этот сервис <code>DirectoryService</code>. Его код будет таким:
    </p>

    <ce:code-example-35/>

    <p>
        У этого сервиса все пути будут начинаться с <code>/directory</code>. Типы запросов только GET.
        Число методов будет увеличиваться в соответствии с размером множества справочных данных.
    </p>

    <p>
        То же самое будет характерно и для фейкового сервера. Создадим
        контроллер <code>DirectoryController</code>:
    </p>

    <ce:code-example-36/>

    <p>
        Теперь подключим его в классе <code>MockServer</code>:
    </p>

    <ce:code-example-37/>

    <p>
        Разумеется, справочные данные следует отразить и в структуре <b>redux</b>. Выделим
        соответствующее поддерево <code>directory</code>, создав одноимённую папку:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/redux-directory-folder.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Код файлов <code>appointmentStatusListActions.js</code> <code>AppointmentStatusListInitialState.js</code>
        и <code>appointmentStatusListReducer.js</code> вам будет уже знаком.
    </p>

    <p>
        Файл <code>appointmentStatusListActions.js</code>:
    </p>

    <ce:code-example-38/>

    <p>
        Файл <code>AppointmentStatusListInitialState.js</code>:
    </p>

    <ce:code-example-39/>

    <p>
        Файл <code>appointmentStatusListReducer.js</code>:
    </p>

    <ce:code-example-40/>

    <p>
        Код остальных redux-файлов такой же, как и для списка приёмов, вы посмотрите
        его немного позже в проекте приложения.
    </p>

    <c:url var="selectorUrl" value="https://reactstrap.github.io/components/form/"/>

    <p>
        Чтобы было удобно фильтровать приёмы по статусу из списка, нам очень подойдёт
        компонент-селектор. В библиотеке reactstrap <b><a href="${selectorUrl}">такой уже есть</a></b>.
    </p>

    <p>
        Давайте создадим простой компонент-декоратор <code>&lt;SelectField&gt;</code>:
    </p>

    <ce:code-example-41/>

    <p>
        По своему коду он почти копия компонента <code>&lt;TextField&gt;</code> с парой отличий,
        важнейшим из которых является свойство <code>type="select"</code>. Оно то и делает
        наш компонент селектором.
    </p>

    <p>
        Теперь нам надо изменить наш контейнер <code>&lt;Appointments&gt;</code>, добавив в фильтр новое
        поле-селектор статусов, а также код их загрузки:
    </p>

    <ce:code-example-42/>

    <p>
        Итак, проанализируем изменения:
    </p>

    <ul>
        <li>
            <p>
                Модифицирован метод <code>mapStateToProps</code>. В возвращаемом объекте появилось
                свойство <code>directory</code>, содержащее все справочные данные.
            </p>
        </li>
        <li>
            <p>
                Модифицирован <code>mapDispatchToProps</code>. Добавлены действия, связанные со статусами.
            </p>
        </li>
        <li>
            <p>
                Добавлен метод <code>loadStatuses</code> для загрузки статусов.
            </p>
        </li>
        <li>
            <p>
                Добавлен компонент <code>SelectField</code> для выбора нужного статуса. Обратите внимание
                на первый option-элемент: <code>{ value: -1, text: '' }</code>. Он всегда будет выбран
                по умолчанию.
            </p>
        </li>
    </ul>

    <p>
        Чтобы всё окончательно заработало осталось модифицировать логику фильтрации:
    </p>

    <ce:code-example-43/>

    <p>
        Теперь все необходимые изменения сделаны. Вы можете посмотреть и
        протестировать полный код приложения:
    </p>

    <br/>

    <iframe
            height="400px"
            width="100%"
            src="https://repl.it/@stsiushkevich/custom-app-v38?lite=true"
            scrolling="no"
            frameborder="no"
            allowtransparency="true"
            allowfullscreen="true"
            sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>

    <br/>
    <br/>

    <br/>
    <h3>5.8.5.2 Способы сокращения кода</h3>
    <br/>

    <p>
        В предыдущем разделе мы ввели удобную абстракцию "справочные данные", которая 
        помогла выделить специальный сервис, контроллер и поддерево состояния. Однако 
        есть и ложка дёгтя: код <code>&lt;Appointments&gt;</code> стал больше. Обратите внимание на
        следующие методы:
    </p>

    <ce:code-example-44/>
    
    <p>
        Согласитесь, не самое приятное зрелище. Для вызова действия мы каждый
        раз должны вызывать <code>this.props.actions</code>, а с увеличением глубины дерева
        строка <code>this.props.actions.status.list.load()</code> будет ещё длиннее.
    </p>

    <p>
        Давайте немного сократим код. Во-первых модифицируем
        функцию <code>mapDispatchToProps()</code>:
    </p>

    <ce:code-example-45/>

    <p>
        Во-вторых, используем такую нативную возможность JS-класса, 
        как "геттер", чтобы сократить <code>this.props.actions</code>:
    </p>

    <ce:code-example-46/>

    <p>
        И тогда наши методы будут выглядеть заметно короче:
    </p>

    <ce:code-example-47/>

    <p>
        Можно даже избавиться от метода <code>changeFormField()</code>.
    </p>

    <br/>
    <iframe
            height="400px"
            width="100%"
            src="https://repl.it/@stsiushkevich/custom-app-v39?lite=true"
            scrolling="no"
            frameborder="no"
            allowtransparency="true"
            allowfullscreen="true"
            sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    <br/>
    <br/>

    <br/>
    <h3>5.8.5.3 Декларативные действия. Компонент Action</h3>
    <br/>

    <p>
        А сейчас я предлагаю вам обратить своё внимание на другой аспект. На текущий
        момент мы в приложении все действия выполняем императивным путём:
    </p>

    <ce:code-example-48/>

    <p>
        То есть объявляем и вызываем методы класса. Рост числа необходимых действий
        вызывает пропорциональный рост числа объявлений и вызовов соответствующих методов.
        Можно, конечно, не объявлять дополнительные методы и вызывать
        <code>this.actions.entity.doSomething()</code> напрямую. Однако, одно и то же
        действие иногда нужно выполнить два и более раз, поэтому отсутствие дополнительного
        метода класса может привести к росту кода и/или ухудшению его читабельности.
    </p>

    <p>
        Столкнувшись с проблемой роста числа методов вида <code>doSomething()</code> я стал
        задумываться об идее декларативного выполнения действия. Моей целью стало
        создание/нахождение компонента, который решал бы следующие задачи:
    </p>

    <ol>
        <li>
            <p>
                <b>Выполнение действия должно происходить декларативным путём.</b>
            </p>
        </li>
        <li>
            <p>
                <b>Минимизация императивных действий в контейнерах.</b>
            </p>
        </li>
        <li>
            <p>
                <b>Сокращение кода контейнеров.</b>
            </p>
        </li>
        <li>
            <p>
                <b>Улучшение или хотя бы сохранение читабельности кода контейнеров.</b>
            </p>
        </li>
    </ol>

    <p>
        Мне не удалось найти ничего готового для императивных действий <b>redux</b>. Поэтому,
        изрядно попотев, я пришел к простой и знакомой абстракции <b>Action</b>. Я вспомнил о
        своей разработке на <b>Swing</b> и <b>Android</b>, и позаимствовал у них несколько концепций.
    </p>

    <app:alert title="Внимание!" type="warning">
        Пожалуйста, если вы знаете что-то какое-то популярное существующее, напишите в
        комментариях - мне будет очень приятно и интересно.
    </app:alert>

    <p>
        У меня получился вот такой компонент:
    </p>

    <ce:code-example-49/>

    <p>
        А его использование выглядит следующим образом:
    </p>

    <ce:code-example-50/>

    <p>
        Теперь давайте проанализируем код компонента:
    </p>

    <ul>
        <li>
            <p>
                Само выполняемое действие(генератор) необходимо передать в свойство <code>action</code>.
            </p>
        </li>
        <li>
            <p>
                Компонент имеет основной метод <code>perform()</code>, который означает выполнение действия.
            </p>
        </li>
        <li>
            <p>
                Чтобы выполнить дополнительные действия после выполнения основного, следует передать
                функцию в свойство <code>onPerformed</code>. В эту функцию будет передан параметр <code>result</code> -
                результат выполненного действия.
            </p>
        </li>
        <li>
            <p>
                Действие можно выполнить в фазе монтирования или демонтирования, о
                чём можно указать в свойстве <code>performingPhase</code>.
            </p>
        </li>
        <li>
            <p>
                По умолчанию действие выполняется однократно в фазе монтирования. Если
                действие нужно выполнить многократно, необходимо передать свойство <code>isMultiple=true</code>.
            </p>
        </li>
        <li>
            <p>
                Многократное выполнение действия должно быть связано с каким-то условием. Его
                нужно задать в свойстве <code>shouldPerform</code>. Это функция, которая принимает параметр
                <code>prevParams</code>. Когда вы выполняете действие с условием, то в компонент <code>&lt;Action&gt;</code>
                необходимо передать параметр <code>params</code>, который означает параметры действия.
                Сверив текущее значение параметра <code>someParam</code> и его предыдущее значение
                <code>prevParams.someParam</code> в методе <code>shouldPerform</code> можно принять однозначное
                решение о выполнении действия. Будьте внимательны и следите за тем, чтобы
                действие не выполнялось бесконечно!
            </p>
        </li>
    </ul>

    <p>
        Итак, введя такой компонент я избавился от императивного выполнения действия:
    </p>

    <ce:code-example-51/>

    <p>
        И получил декларативное:
    </p>

    <ce:code-example-52/>

    <p>
        Таким образом я достиг решения задач 1, 2, 3 и, возможно, частично 4. Но этого мне
        было мало. Я тут же увидел, что можно пойти ещё дальше и создать контейнер-действие,
        который будет инкапсулировать строго одно определённое действие, а поместить такие
        контейнеры можно в папку <code>/actions</code>. Давайте создадим такой контейнер-действие для
        загрузки статусов приёмов, разместив его в папке <code>/actions/directory</code>. Исходный код
        компонента будет такой:
    </p>

    <ce:code-example-53/>

    <p>
        Теперь вместо <code>&lt;Action action={this.actions.statuses.load} /&gt;</code> я
        получил <code>&lt;LoadAppointmentStatusesAction/&gt;</code>. Запись заметно короче, что не может не радовать.
        Ещё одним приятным бонусом стала <b>возможность повторного использования контейнера-действия</b>.
    </p>

    <p>
        Также следует отметить, что контейнер-действие использует компонент <code>&lt;Action&gt;</code> и
        может выполнять лишь одно заранее определённое действие. Кроме того, контейнер
        ведет себя абсолютно также как и сам <code>&lt;Action&gt;</code> за счёт делегирования свойств.
    </p>

    <p>
        Глядя на код контейнера-действия, можно заметить, что он имеет типовую структуру.
        То есть все контейнеры-действия будут иметь почти одинаковый код. Это даёт потрясающую
        возможность создать фабрику действий <code>ActionFactory</code>, которая будет возвращать нужный
        контейнер-действие:
    </p>

    <ce:code-example-54/>

    <p>
        В итоге объявление контейнера-действия теперь будет таким:
    </p>

    <ce:code-example-55/>

    <p><b>Потрясающе! Получилось очень коротко.</b></p>
    
    <p>
        Это именно то, что я хотел. Все четыре поставленные задачи
        декларативного выполнения действия теперь решены.
    </p>

    <p>
        Конечно, использовать такой подход или нет, решать вам. Для кого-то он
        может показаться полным абсурдом, для кого-то слишком сложным и/или запутанным.
        Так или иначе, идея декларативного выполнения действия помогла мне очень сильно
        сократить код моих контейнеров, заметно повысить их читабельность, минимизировать
        императивную составляющую, снизить вероятность ошибок, дала преимущество повторного
        использования контейнеров-действий. Поэтому я решил поделиться моим решением с вами.
        Ваши мысли вы можете оставлять в комментариях, я буду стараться отвечать. Возможно,
        вы сможете предложить что-то существующее или гораздо лучшее!
    </p>

    <p>
        Кстати, спустя время, пробегая глазами по библиотеке <b>apollo</b>, я наткнулся на
        нечто похожее. Там есть компонент запроса <code>&lt;Query&gt;</code>. Он выполняет GraphQL запрос,
        по окончании которого отрисовывает своё содержимое. Выглядит это так:
    </p>

    <ce:code-example-56/>

    <p>
        Что ж, видимо создание нашего redux-аналога <code>&lt;Action&gt;</code> было не зря:)
    </p>

    <p>
        Вот окончательный пример приложения после рефакторинга:
    </p>

    <br/>
    <iframe
            height="400px"
            width="100%"
            src="https://repl.it/@stsiushkevich/custom-app-v310?lite=true"
            scrolling="no"
            frameborder="no"
            allowtransparency="true"
            allowfullscreen="true"
            sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    <br/>
    <br/>
</lt:layout>

<c:url var="prevPageUrl" value="/training-project/async-data-loading"/>
<c:url var="nextPageUrl" value="/training-project/summary"/>

<app:page-navigate
        prevPageUrl="${prevPageUrl}"
        pageStartAncor="pageStart"
        nextPageUrl="${nextPageUrl}"
/>