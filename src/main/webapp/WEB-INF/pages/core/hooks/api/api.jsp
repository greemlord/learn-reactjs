<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/hooks/api" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page hooks-glance-page">
    <h1>3.12.7 Справка по API хуков</h1>
    
    <br/>
    
    <p class="introduction">
        Хуки доступны в версии <b>React 16.8</b>. Они позволяют использовать состояние и другие
        функции React, освобождая от необходимости писать класс.
    </p>
    
    <br/>
    
    <p>
        В данном разделе описан API для встроенных хуков React.
    </p>
    
    <c:url var="glanceUrl" value="/core/hooks/glance"/>
    <c:url var="faqUrl" value="https://reactjs.org/docs/hooks-faq.html"/>
    
    <p>
        Если вы новичок в хуках, то сначала можете ознакомиться с <b><a href="${glanceUrl}">обзором</a></b>.
        Помимо прочего вы можете найти много полезной информации в разделе
        <b><a href="${faqUrl}">часто задаваемых вопросов</a></b>.
    </p>
    
    <br/>
    
    <ul>
        <li><p><b><a href="#baseHooks">Базовые хуки</a></b></p>
            <ul>
                <li><p><b><a href="#useState">useState</a></b></p></li>
                <li><p><b><a href="#useEffect">useEffect</a></b></p></li>
                <li><p><b><a href="#useContext">useContext</a></b></p></li>
            </ul>
        </li>
        <li><p><b><a href="#additionalHooks">Дополнительные хуки</a></b></p>
            <ul>
                <li><p><b><a href="#useReducer">useReducer</a></b></p></li>
                <li><p><b><a href="#useCallback">useCallback</a></b></p></li>
                <li><p><b><a href="#useMemo">useMemo</a></b></p></li>
                <li><p><b><a href="#useRef">useRef</a></b></p></li>
                <li><p><b><a href="#useImperativeHandle">useImperativeHandle</a></b></p></li>
                <li><p><b><a href="#useLayoutEffect">useLayoutEffect</a></b></p></li>
                <li><p><b><a href="#useDebugValue">useDebugValue</a></b></p></li>
            </ul>
        </li>
    </ul>
    
    <a name="baseHooks"></a>
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.7.1 Базовые хуки</h2>
    <br/>
    
    <a name="useState"></a>
    <br/>
    <h3>3.12.7.1.1 useState</h3>
    <br/>
    
    <ce:code-example-1/>
    
    <p>Возвращает значение с состоянием и функцию для его обновления.</p>
    
    <p>
        Во время начальной отрисовки возвращаемое состояние <code>state</code> совпадает со значением <code>initialState</code>,
        передаваемым в качестве первого аргумента.
    </p>
    
    <p>
        Функция <code>setState</code> обновляет состояние. Она принимает
        новое значение состояния и ставит в очередь повторную отрисовку компонента.
    </p>
    
    <ce:code-example-2/>
    
    <p>
        Во время последующих отрисовок первое значение, которое
        возвращает <code>useState</code>, всегда будет самым последним состоянием, после
        того как все обновления были применены.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        React гарантирует, что функция <code>setState</code> остается стабильной и неизменной
        при повторных отрисовках. Поэтому её без всяких опасений можно не указывать в списке
        зависимостей у хуков <code>useEffect</code> или <code>useCallback</code>.
    </app:alert>
    
    <br/>
    <h3>3.12.7.1.1.1 Обновления состояния в функциональной форме</h3>
    <br/>
    
    <p>
        Если для того, чтобы вычислить новое состояние, вам нужно предыдущее состояние,
        вы можете передать функцию в <code>setState</code>. Эта функция получит предыдущее значение и вернет
        обновленное значение. Вот пример компонента счетчика, который использует обе формы <code>setState</code>:
    </p>
    
    <ce:code-example-3/>
    
    <p>
        Кнопки <code>+</code> и <code>-</code> используют функциональную форму обновления состояния,
        так как обновленное значение основано на предыдущем значении. Однако кнопка «Сброс» использует
        обычную форму и всегда устанавливает <code>count</code> обратно к начальному значению.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        В отличие от метода <code>setState</code>, характерного для компонентов-классов, <code>useState</code>
        не объединяет(мерджит) объекты обновления автоматически. Однако вы сами можете
        реализовать такое поведение, комбинируя функциональную форму обновления со <code>spread</code>
        синтаксисом для объекта:
        
        <br/>
        <ce:code-example-4/>
    
        Другой вариант - <code>useReducer</code>, который больше подходит для управления объектами состояния,
        содержащих множество вложенных значений.
    </app:alert>
    
    <br/>
    <h3>3.12.7.1.1.2 Ленивая установка начального состояния</h3>
    <br/>
    
    <p>
        Аргумент <code>initialState</code> - это состояние, которое будет использовано только во время начальной отрисовки.
        В последующих отрисовках он игнорируется. Если начальное состояние - это результат дорогостоящих
        вычислений, то в первый аргумент можно передать функцию, которая будет выполнена
        только при начальной отрисовке:
    </p>
    
    <ce:code-example-5/>
    
    <br/>
    <h3>3.12.7.1.1.3 Отмена обновления состояния</h3>
    <br/>
    
    <c:url var="objectIsUrl" value="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"/>
    <p>
        Если вы обновите хук состояния тем же значением, что и текущее состояние, React
        прекратит обновление компонента и выйдет из хука. Также он не будет отрисовывать дочерние
        элементы и запускать эффекты. (React использует алгоритм сравнения <b><a href="${objectIsUrl}">Object.is</a></b>.)
    </p>
    
    <p>
        Обратите внимание на то, что библиотеке React, возможно, понадобится снова отрисовать
        определенный компонент, прежде чем прекратить его обновление. Не беспокойтесь об этом:
        React не будет излишне углубляться в дерево. Если вы выполняете дорогостоящие
        вычисления во время отрисовки, можете оптимизировать их с помощью <code>useMemo</code>.
    </p>
    
    <a name="useEffect"></a>
    <br/>
    <h3>3.12.7.1.2 useEffect</h3>
    <br/>
    
    <ce:code-example-6/>
    
    <p>
        Принимает функцию с императивным кодом, который в
        свою очередь может содержать эффекты.
    </p>
    
    <p>
        Мутации, подписки, таймеры, логирование и любые другие побочные
        эффекты не допустимы внутри основного тела компонента-функции. Иначе
        это приведет к запутанным ошибкам и несоответствиям в UI.
    </p>
    
    <p>
        Здесь на помощь приходит <code>useEffect</code>. Функция, переданная <code>useEffect</code>,
        будет запущена после того, как результат отрисовки будет зафиксирован и отображен на экране.
        Представляйте эффекты как мост из чисто функционального мира React в императивный мир.
    </p>
    
    <p>
        По умолчанию эффекты запускаются после завершения каждой отрисовки. Однако
        у вас есть возможность вызвать их после того, как изменились определенные значения.
    </p>
    
    <br/>
    <h4>3.12.7.1.2.1 Очистка эффекта</h4>
    <br/>
    
    <p>
        Часто эффекты создают ресурсы, которые необходимо очистить перед тем,
        как компонент будет демонтирован. Примерами могут служить подписки или
        идентификатор таймера. Чтобы сделать очистку, функция, переданная <code>useEffect</code>,
        может вернуть функцию очистки. Вот простой пример:
    </p>
    
    <ce:code-example-7/>
    
    <p>
        Функция очистки запускается до удаления компонента из UI, чтобы предотвратить
        утечки памяти. Кроме того, если компонент отрисовывается несколько раз (так обычно и происходит),
        предыдущий эффект очищается перед выполнением следующего эффекта. Для нашего примера
        это означает, что новая подписка создается при каждом обновлении. Чтобы избежать
        запуска эффекта на каждом обновлении, читайте далее.
    </p>
    
    <br/>
    <h4>3.12.7.1.2.2 Управление временем запуска эффектов</h4>
    <br/>
    
    <p>
        В отличие от <code>componentDidMount</code> и <code>componentDidUpdate</code>,
        функция, переданная <code>useEffect</code>,
        срабатывает после компоновки(layout) и рисования(paint) во время отложенного события. Это делает её подходящей
        для запуска многих распространенных эффектов, таких как настройка подписок и обработчиков
        событий, так как большинство типов действий не должны блокировать браузер во время
        обновления экрана.
    </p>
    
    <p>
        Однако не все эффекты могут быть отложены. Например, мутация DOM, которая видна пользователю,
        должна запускаться синхронно перед следующим рисованием(paint), чтобы пользователь не заметил
        визуальное несоответствие. (Различие концептуально аналогично различию между пассивными и
        активными слушателями событий.) Для этих типов эффектов React предоставляет еще один хук,
        называемый <code>useLayoutEffect</code>. Он имеет ту же сигнатуру, что и <code>useEffect</code>, и отличается
        только моментом запуска.
    </p>
    
    <p>
        Хотя <code>useEffect</code> откладывается до тех пор, пока браузер не выполнит прорисовку, он
        гарантированно срабатывает перед любыми новыми отрисовками компонента. React всегда
        запускает все эффекты предыдущей отрисовки перед началом очередного обновления.
    </p>
    
    <br/>
    <h4>3.12.7.1.2.3 Запуск эффектов по условию</h4>
    <br/>
    
    <p>
        Поведение эффектов по умолчанию: эффект запускается после каждой завершенной
        отрисовки. Таким образом, эффект всегда пересоздаётся, если изменяется одна из его зависимостей.
    </p>
    
    <p>
        Однако иногда это может оказаться лишним. Вспомним пример подписки
        из предыдущего пункта. Допустим, нам не нужно создавать новую подписку в каждом обновлении,
        за исключением случая, когда свойство <code>source</code> изменилось.
    </p>
    
    <p>
        Чтобы добиться этого, передайте функции <code>useEffect</code> второй аргумент,
        который является массивом значений. От этих значений будет зависеть эффект. Теперь наш
        обновленный пример выглядит так:
    </p>
    
    <ce:code-example-8/>
    
    <p>
        Теперь подписка будет пересоздаваться только
        при изменении <code>props.source</code>.
    </p>
    
    <c:url var="faq1Url" value="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies"/>
    <c:url var="faq2Url" value="https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often"/>
    <c:url var="faq3Url" value="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies"/>
    
    <app:alert title="Внимание!" type="warning">
        Используя эту оптимизацию, убедитесь, что массив, используемый эффектом, включает в себя
        значения <b>только из области компонента (например, из props и state), которые
        должны изменяться со временем</b>. В противном случае ваш код
        будет ссылаться на устаревшие значения из предыдущих отрисовок. Узнайте
        больше о том, <b><a href="${faq1Url}">как работать с функциями</a></b> и что делать,
        если <b><a href="${faq2Url}">значения массива меняются слишком часто</a></b>.
        <br/>
        <br/>
        Если вы хотите запустить эффект и очистить его только один раз (при монтировании
        и демонтировании), вы можете передать пустой массив <code>[]</code> в качестве второго аргумента.
        Это говорит React, что ваш эффект не зависит от каких-либо значений из <code>props</code> или <code>state</code>,
        поэтому его не нужно запускать повторно. React не обрабатывает это как особый случай -
        это непосредственно следует из традиционного поведения массива зависимостей.
        <br/>
        <br/>
        Если вы передадите пустой массив <code>[]</code> в <code>useEffect</code>, то <code>props</code> и <code>state</code>
        внутри эффекта всегда будут иметь свои начальные значения. Хотя передача <code>[]</code> в качестве второго аргумента
        ближе к знакомой ментальной модели методов <code>componentDidMount</code> и <code>componentWillUnmount</code>,
        существуют и <b><a href="${faq3Url}">более эффективные решения</a></b>, позволяющие избежать слишком частого
        повторного запуска эффектов. Кроме того, не забывайте, что React откладывает
        запуск <code>useEffect</code> до тех пор, пока браузер не выполнит рисование, поэтому
        выполнить некоторую дополнительную работу можно без всяких проблем.
        <br/>
        <br/>
        Мы рекомендуем использовать правило <code>exhaustive-deps</code> как часть нашего
        пакета <code>eslint-plugin-react-hooks</code>. Оно показывает предупреждение, когда зависимости указаны
        неправильно, и предлагает исправление.
    </app:alert>
    
    <p>
        В качестве аргумента функции эффекта, конечно, не передается никакого массива зависимостей.
        Однако, концептуально, поведение идентично: каждое значение, на
        которое ссылается функция эффекта, должно присутствовать в массиве зависимостей.
        В будущем наш продвинутый компилятор будет создавать этот массив автоматически.
    </p>
    
    <a name="useContext"></a>
    <br/>
    <h3>3.12.7.1.3 useContext</h3>
    <br/>
    
    <ce:code-example-9/>
    
    <p>
        Принимает объект контекста (значение, возвращаемое из <code>React.createContext</code>)
        и возвращает текущее значение контекста. Текущее значение контекста определяется
        свойством <code>value</code> ближайшего <code>&lt;MyContext.Provider&gt;</code> над
        вызывающим компонентом в дереве.
    </p>
    
    <p>
        Когда ближайший <code>&lt;MyContext.Provider&gt;</code> над компонентом обновляется, этот
        хук инициирует повторную отрисовку с последним значением контекста, переданным
        провайдеру <code>MyContext</code>.
    </p>
    
    <p>
        Помните, что аргументом <code>useContext</code> должен быть сам объект контекста:
    </p>
    
    <ul>
        <li>
            <p>
                <b>Правильно:</b> <code>useContext(MyContext)</code>
            </p>
        </li>
        <li>
            <p>
                <b>Неправильно:</b> <code>useContext(MyContext.Consumer)</code>
            </p>
        </li>
        <li>
            <p>
                <b>Неправильно:</b> <code>useContext(MyContext.Provider)</code>
            </p>
        </li>
    </ul>
    
    <c:url var="memoizationUrl" value="https://github.com/facebook/react/issues/15156#issuecomment-474590693"/>
    
    <p>
        Компонент, который вызывает <code>useContext</code>, будет перерисован каждый раз при
        изменении значения контекста. Если повторная отрисовка компонента
        достаточно дорогая, вы можете <b><a href="${memoizationUrl}">оптимизировать её, используя мемоизацию</a></b>.
    </p>
    
    <app:alert title="Подсказка!" type="success">
        Если вы уже знакомы с API контекста, то <code>useContext(MyContext)</code>
        эквивалентен <code>static contextType = MyContext</code> в классе
        или <code>&lt;MyContext.Consumer&gt;</code>.
        <br/>
        <br/>
        <code>useContext(MyContext)</code> позволяет только читать контекст и
        подписываться на его изменения. Вам всё еще нужен
        <code>&lt;MyContext.Provider&gt;</code> выше в дереве,
        чтобы предоставлять значение для этого контекста.
    </app:alert>
    
    <a name="additionalHooks"></a>
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.7.2 Дополнительные хуки</h2>
    <br/>
    
    <p>
        Следующие хуки являются либо дополнительными вариантами базовых,
        перечисленных ранее, либо необходимы только для каких-то специфических случаев.
    </p>
    
    <a name="useReducer"></a>
    <br/>
    <h3>3.12.7.2.1 useReducer</h3>
    <br/>
    
    <ce:code-example-10/>
    
    <p>
        Это альтернатива <code>useState</code>. Принимает редюсер
        типа <code>(state, action) => newState</code> и
        возвращает текущее состояние в паре с методом <code>dispatch</code>. (Если вы уже
        знакомы с Redux, то знаете, как это работает.)
    </p>
    
    <c:url var="passingCallbacksUrl" value="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down"/>
    
    <p>
        Обычно <code>useReducer</code> предпочтительнее <code>useState</code>, когда у вас сложная
        логика состояния, работающая с несколькими значениями, или
        когда следующее состояние зависит от предыдущего. <code>useReducer</code> также
        позволяет оптимизировать производительность компонентов, которые
        запускают глубокие обновления, поскольку вы можете
        <b><a href="${passingCallbacksUrl}">передавать <code>dispatch</code> вместо обычных коллбэков</a></b>.
    </p>
    
    <p>
        Вот пример счетчика из пункта о <code>useState</code>, переписанный для использования редюсера:
    </p>
    
    <ce:code-example-11/>
    
    <app:alert title="Внимание!" type="warning">
        React гарантирует, что функция <code>dispatch</code> остается стабильной и неизменной
        при повторных отрисовках. Поэтому её без всяких опасений можно не указывать в списке
        зависимостей у хуков <code>useEffect</code> или <code>useCallback</code>.
    </app:alert>
    
    <p class="text-center">
        <b>раздел в разработке...</b>
    </p>
    
    <br/>
    <h4>3.12.7.2.1.1 Указание начального состояния</h4>
    <br/>
    
    <p>
        Существует два разных способа инициализации состояния <code>useReducer</code>.
        Вы можете выбрать любой из них в зависимости от ситуации. Самый простой способ -
        передать начальное состояние вторым аргументом:
    </p>
    
    <ce:code-example-12/>
    
    <app:alert title="Внимание!" type="warning">
        React не использует инициализацию состояния в аргументе типа <code>state = initialState</code>,
        которое так популярно в Redux. Иногда начальное значение должно зависеть от
        свойств <code>props</code>, поэтому оно указывается в вызове хука. Если вы чувствуете себя
        некомфортно, то можете вызвать <code>useReducer(reducer, undefined, reducer)</code>, чтобы
        эмулировать поведение Redux, но это не рекомендуется.
    </app:alert>
    
    <br/>
    <h4>3.12.7.2.1.2 Ленивая инициализация</h4>
    <br/>
    
    <p>
        Второй способ заключается в ленивом/отложенном создании начального состояния.
        Для этого вам нужно передать функцию <code>init</code> в качестве третьего аргумента. Начальное
        состояние будет установлено в значение <code>init(initialArg)</code>.
    </p>
    
    <p>
        Такой метод позволяет извлечь логику для вычисления начального состояния
        за пределы редюсера. Также это очень удобно для сброса состояния в ответ на действие:
    </p>
    
    <ce:code-example-13/>
    
    <br/>
    <h4>3.12.7.2.1.3 Прекращение процесса диспетчеризации</h4>
    <br/>
    
    <c:url var="objectIsUrl" value="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is"/>
    
    <p>
        Если из хука редюсера вы вернете то же самое значение значение состояния
        что и текущее, React прекратит диспетчеризацию. При этом отрисовки дочерних элементов или
        срабатывания эффектов не будет. (React использует <b><a href="${objectIsUrl}">алгоритм
        сравнения Object.is</a></b>).
    </p>
    
    <p>
        Обратите внимание: библиотеке React может понадобиться снова отрисовать этот
        конкретный компонент, прежде чем прекратить диспетчеризацию. Не беспокойтесь
        об этом, React не будет излишне "углубляться" в дерево. Если же вы выполняете
        дорогостоящие вычисления во время отрисовки, то можете оптимизировать
        их с помощью <code>useMemo</code>.
    </p>
    <p></p>
    
    <a name="useCallback"></a>
    <br/>
    <h3>3.12.7.2.2 useCallback</h3>
    <br/>
    
    <ce:code-example-14/>
    
    <c:url var="memoizationUrl" value="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F"/>
    
    <p>Возвращает <b><a href="${memoizationUrl}">мемоизированный</a></b> коллбэк.</p>
    
    <p>
        Передайте колбэк и массив зависимостей. <code>useCallback</code> вернет мемоизированную
        версию этого колбэка, которая изменяется только в случае изменения одной из
        зависимостей. Это полезно при передаче колбэков оптимизированным дочерним
        компонентам, которые полагаются на равенство ссылок для предотвращения
        ненужных отрисовок (например в методе <code>shouldComponentUpdate</code>).
    </p>
    
    <p>
        <code>useCallback(fn, deps)</code> это эквивалент <code>useMemo(() => fn, deps)</code>.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        Массив зависимостей не передаётся как аргумент колбэка. Хотя концептуально
        поведение идентично: каждое значение, на которое ссылается колбэк, должно присутствовать
        в массиве зависимостей. В будущем наш продвинутый компилятор будет создавать этот массив автоматически.
        <br/>
        <br/>
        <c:url var="issue14920Url" value="https://github.com/facebook/react/issues/14920"/>
        <c:url var="eslintPluginReactHooksUrl" value="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"/>
        Мы рекомендуем использовать правило <b><a href="${issue14920Url}">exhaustive-deps</a></b> как часть нашего
        пакета <b><a href="${eslintPluginReactHooksUrl}">eslint-plugin-react-hooks</a></b>. Оно показывает предупреждение, когда зависимости указаны
        неправильно, и предлагает исправление.
    </app:alert>
    
    <a name="useMemo"></a>
    <br/>
    <h3>3.12.7.2.3 useMemo</h3>
    <br/>
    
    <ce:code-example-15/>
    
    <p>
        Возвращает <b><a href="${memoizationUrl}">мемоизированное</a></b> значение.
    </p>
    
    <p>
        Передайте производящую функцию и массив зависимостей. <code>useMemo</code> будет
        повторно вычислять мемоизированное значение только в том случае, когда одна
        из зависимостей изменилась. Такая оптимизация помогает избежать дорогостоящих
        расчетов при каждой отрисовке.
    </p>
    
    <p>
        Помните, что функция, переданная <code>useMemo</code>, запускается во время
        отрисовки, так что не делайте в ней никаких сторонних действий
        (то, чего вы обычно не делаете во время отрисовки). Например,
        побочные эффекты принадлежат <code>useEffect</code>, а не <code>useMemo</code>.
    </p>
    
    <p>
        Если массив не указан, новое значение будет вычисляться при
        каждой отрисовке, и никакого выигрыша от использования <code>useMemo</code> не будет.
    </p>
    
    <p>
        <b>Рассматривайте useMemo как оптимизацию производительности, а не как
        семантическую гарантию.</b> В любой момент React может предпочесть <b>забыть</b>
        некоторые ранее мемоизированные значения и пересчитать их при следующей отрисовке,
        например, чтобы освободить память для компонентов, находящихся вне экрана.
        Сначала напишите правильный код, который работает без <code>useMemo</code>, а затем добавьте
        этот хук для оптимизации производительности.
    </p>
    
    <app:alert title="Внимание!" type="warning">
        Массив зависимостей не передаётся как аргумент колбэка. Хотя концептуально
        поведение идентично: каждое значение, на которое ссылается колбэк, должно присутствовать
        в массиве зависимостей. В будущем наш продвинутый компилятор будет создавать этот массив автоматически.
        <br/>
        <br/>
        <c:url var="issue14920Url" value="https://github.com/facebook/react/issues/14920"/>
        <c:url var="eslintPluginReactHooksUrl" value="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"/>
        Мы рекомендуем использовать правило <b><a href="${issue14920Url}">exhaustive-deps</a></b> как часть нашего
        пакета <b><a href="${eslintPluginReactHooksUrl}">eslint-plugin-react-hooks</a></b>. Оно показывает предупреждение, когда зависимости указаны
        неправильно, и предлагает исправление.
    </app:alert>
    
    <a name="useRef"></a>
    <br/>
    <h3>3.12.7.2.4 useRef</h3>
    <br/>
    
    <ce:code-example-16/>
    
    <p>
        <code>useRef</code> возвращает изменяемый объект <code>ref</code>, чьё свойство <code>.current</code>
        инициализируется переданным аргументом <code>initialValue</code>. Возвращенный
        объект будет сохранён в течение всего времени жизни компонента.
    </p>
    
    <p>
        Обычный вариант использования - это императивный доступ к дочернему элементу:
    </p>
    
    <ce:code-example-17/>
    
    <p>
        По сути, <code>useRef</code> похож на "коробку", которая может
        хранить изменяемое значение в своём свойстве <code>.current</code>.
    </p>
    
    <p>
        Вероятно, вы знакомы с ссылками в первую очередь как способ доступа к DOM.
        Если вы передадите объект <code>ref</code> в React с помощью <code>&lt;div ref = {myRef} /&gt;</code>,
        React будет устанавливать его свойство <code>.current</code> в соответствующий узел DOM
        каждый раз, когда этот узел изменяется.
    </p>
    
    <p>
        Однако <code>useRef()</code> полезен не только для атрибута <code>ref</code>. Он удобен для
        хранения любого изменяемого значения почти так же, как и поля
        экземпляра класса.
    </p>
    
    <p>
        Это возможно благодаря тому, потому что <code>useRef()</code> создает простой
        объект JavaScript. Единственное отличие между <code>useRef()</code> и созданием
        объекта <code>{current: ...}</code> заключается в том, что <code>useRef</code> будет возвращать
        вам один и тот же объект <code>ref</code> при каждой отрисовке.
    </p>
    
    <p>
        Имейте в виду, что <code>useRef</code> не уведомляет вас о мутации своего содержимого.
        Изменение свойства <code>.current</code> не приведёт к повторной отрисовке. Если вы
        хотите запустить какой-то код, когда React присоединяет или отсоединяет
        ссылку на узел DOM, для <code>ref</code> лучше
        использовать колбэк: <code>ref={ elem => { ... } }</code>.
    </p>
    
    <p></p>
    
    <a name="useImperativeHandle"></a>
    <br/>
    <h3>3.12.7.2.5 useImperativeHandle</h3>
    <br/>
    
    <ce:code-example-18/>
    
    <p>
        <code>useImperativeHandle</code> кастомизирует значение экземпляра <code>ref</code>, предоставленного
        родительским компонентом. Напоминаем, что в большинстве случаев следует избегать
        императивного кода с использованием ссылок <code>ref</code>. <code>useImperativeHandle</code>
        следует использовать вместе с <code>forwardRef</code>:
    </p>
    
    <ce:code-example-19/>
    
    <a name="useLayoutEffect"></a>
    <br/>
    <h3>3.12.7.2.6 useLayoutEffect</h3>
    <br/>
    
    <ce:code-example-19.1/>
    
    <p>
        Сигнатура метода идентична <code>useEffect</code>, однако он запускается синхронно после
        всех мутаций DOM. Используйте его для чтения лэйаута из DOM и синхронной повторной
        отрисовки. Обновления, запланированные внутри <code>useLayoutEffect</code>, будут сбрасываться
        синхронно до того, как браузер сможет что-то отрисовать.
    </p>
    
    <p>
        По возможности предпочитайте стандартный <code>useEffect</code>,
        чтобы избежать блокировки визуальных обновлений.
    </p>
    
    <app:alert title="Подсказка." type="success">
        Если вы делаете миграцию кода из компонента класса, обратите внимание,
        что <code>useLayoutEffect</code> запускается в той же фазе, что и методы
        <code>componentDidMount</code> и <code>componentDidUpdate</code>. Однако мы рекомендуем
        сперва начать с <code>useEffect</code>, и только в том случае, если возникнут
        проблемы попытаться использовать <code>useLayoutEffect</code>.
        <br/>
        <br/>
        Если вы используете отрисовку на стороне сервера, имейте в виду,
        что ни <code>useLayoutEffect</code>, ни <code>useEffect</code> не могут работать до тех пор,
        пока не будет загружен JavaScript. Вот почему React показывает предупреждение,
        когда отрисовываемый сервером компонент содержит <code>useLayoutEffect</code>. Чтобы
        его исправить, либо переместите всю логику в <code>useEffect</code> (если она не обязательна
        для первой отрисовки), либо отложите показ этого компонента до тех пор, пока
        клиент не выполнит отрисовку (если HTML выглядит сломанным
        до запуска <code>useLayoutEffect</code>).
        <br/>
        <br/>
        Чтобы исключить компонент, которому требуются эффекты лэйаута, из отрисованного
        сервером HTML-кода, отрисовывайте его условно с помощью <code>isChildShowed && &lt;Child /&gt;</code>
        и отложите его показ с помощью <code>useEffect(() => {showChild(true);}, [])</code>.
        Таким образом, пользовательский интерфейс не будет выглядеть
        сломанным до своего оживления.
    </app:alert>
    
    <a name="useDebugValue"></a>
    <br/>
    <h3>3.12.7.2.7 useDebugValue</h3>
    <br/>
    
    <ce:code-example-20/>
    
    <p>
        <code>useDebugValue</code> может использоваться, чтобы отображать
        метки пользовательских хуков в <b>React DevTools</b>.
    </p>
    
    <c:url var="customHookUrl" value="/core/hooks/custom-hook"/>
    
    <p>
        Для примера рассмотрим пользовательский хук <code>useFriendStatus</code>,
        из раздела <b><a href="${customHookUrl}">Пользовательский хук</a></b>:
    </p>
    
    <ce:code-example-21/>
    
    <app:alert title="Подсказка." type="success">
        Мы не рекомендуем добавлять значения отладки в каждый пользовательский хук. Эта
        возможность наиболее рациональна для пользовательских хуков, которые являются
        частью общих библиотек.
    </app:alert>
    
    <br/>
    <h4>Отложенное форматирование значений отладки</h4>
    <br/>
    
    <p>
        В некоторых случаях форматирование отображаемого значения может быть
        дорогостоящей операцией. Этого не нужно и тогда, когда хук ещё не проверен.
    </p>
    
    <p>
        По этой причине <code>useDebugValue</code> принимает функцию форматирования в качестве
        необязательного второго параметра. Эта функция вызывается только после проверки хука.
        Она получает значение отладки в качестве параметра и должна возвращать форматированное
        отображаемое значение.
    </p>
    
    <p>
        Например, пользовательский хук, который возвращает значение типа <code>Date</code>, может
        избежать ненужного вызова функции <code>toDateString</code>, передав
        следующий форматтер:
    </p>
    
    <ce:code-example-22/>
    
    <%-- <c:url var="Url" value=""/> --%>
    <%--
		<ul>
			<li>
				<p>

				</p>
			</li>
		</ul>
		--%>
    <%-- <app:alert title="Внимание!" type="warning"></app:alert> --%>
    <%-- <code></code> --%>
    <%-- <b></b> --%>
    <%-- <code>&lt; &gt;</code> --%>
    <%-- <b><a href="${}"></a></b> --%>
    <%-- <b><a href="#"></a></b> --%>
    <%-- <a href="#"></a> --%>

</div>

<c:url var="prevPageUrl" value="/core/hooks/rules"/>

<app:page-navigate
    pageStartAncor="pageStart"
    prevPageUrl="${prevPageUrl}"
/>